(function () {
	'use strict';

	class Util {
		
		static Mixin(a, b) {				
			for (var key in b) {
				if (b.hasOwnProperty(key)) a[key] = b[key];
			}

			return arguments[0];
		}
		
		static Debounce(delegate, threshold) {
			var timeout;
		
			return function debounced () {
				
				function delayed () {
					delegate.apply(this, arguments);
					
					timeout = null; 
				}
		 
				if (timeout) clearTimeout(timeout);
		 
				timeout = setTimeout(delayed.bind(this), threshold || 100); 
			};
		}
		
		static Format(str, subs) {
			if (!subs || subs.length == 0) return str;
			
			var s = str;

			for (var i = 0; i < subs.length; i++) {
				var reg = new RegExp("\\{" + i + "\\}", "gm");
				s = s.replace(reg, subs[i]);
			}

			return s;
		}
	}

	let _nls = null;
	let _locale = null;
	let _templatables = {};

	class Core {
		
	    static get nls() { return _nls; }
		
	    static set nls(value) { _nls = value; }
		
	    static get locale() { return _locale; }
		
	    static set locale(value) { _locale = value; }
		
		static Nls(id, subs, locale) {
			if (!this.nls) throw new Error("Nls content not set.");
			
			var itm = this.nls[id];

			if (!itm) throw new Error("Nls String '" + id + "' undefined.");

			var txt = itm[(locale) ? locale : this.locale];

			if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");

			return Util.Format(txt, subs);
		}
			
		static Defer() {
			var defer = {};
			
			defer.promise = new Promise((resolve, reject) => {
				defer.Resolve = (result) => { resolve({ result:result }); };
				defer.Reject = (error) => { reject({ error:error }); };
			});
			
			return defer;
		}
		
		static Templatable(id, definition) {
			if (definition) {
				if (_templatables[id]) throw new Error(`Templatable ${id} is defined multiple times.`);
				
				else _templatables[id] = definition;
			}
			else if (!_templatables[id]) throw new Error(`Templatable ${id} is not defined.`);
			
			return _templatables[id];
		}
		
		static Templated(namespace) {
			var templated = [];
			
			for (var id in _templatables) {
				if (id.match(namespace)) templated.push(_templatables[id]);
			}
			
			return templated;
		}
	}

	class Dom {
		
		static Node(pNode, selector) {
			return pNode.querySelectorAll(selector).item(0) || null;
		}

		static Create(tagName, options, pNode) {
			var elem = document.createElement(tagName);
			
			Util.Mixin(elem, options);
			
			this.Place(elem, pNode);
			
			return elem
		}

		static CreateSVG(tagName, options, pNode) {
			var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);
			
			for (var id in options) elem.setAttribute(id, options[id]);
			
			this.Place(elem, pNode);
			
			return elem;
		}

		static CreateNS(ns, tagName, options, pNode) {
			var elem = document.createElementNS(ns, tagName);
			
			for (var id in options) elem.setAttribute(id, options[id]);
			
			this.Place(elem, pNode);
			
			return elem;
		}

		static Place(elem, pNode) {
			if (!!pNode) pNode.appendChild(elem);
		}

		static Replace(elem1, elem2) {
			var pNode = elem1.parentNode;
			
			pNode.insertBefore(elem2, elem1);

			this.Remove(elem1, pNode);
		}

		static Remove(elem, pNode) {
			if (!pNode.children.some(function(child) { return (child === elem); })) return;
			
			pNode.removeChild(elem);
		}

		static Empty(elem) {
			while (elem.firstChild) {
				elem.removeChild(elem.firstChild);
			}
		}

		static AddCss(domNode, css) {
			var c1 = domNode.className.split(" ");
			
			css.split(" ").forEach(function(c) {
				if (!c1.includes(c)) c1.push(c);
			});
			
			domNode.className = classes.join(" "); 
		}

		static RemoveCss(domNode, css) {				
			var c1 = domNode.className.split(" ");
			var c2 = css.split(" ");
			
			c1.filter(function(c) { return c2.indexOf(c) == -1; });
			
			domNode.className = classes.join(" "); 
		}

		static HasCss(domNode, css) {
			return (' ' + domNode.className + ' ').indexOf(' ' + css + ' ') > -1;
		}

		static SetCss(domNode, css) {
			domNode.className = css; 
		}

		static ToggleCss(domNode, css, enabled) {
			if (enabled) this.AddCss(domNode, css);
			
			else this.RemoveCss(domNode, css);
		}
		
		static GetAttribute(domNode, attr) {
			var attr = domNode.attributes.getNamedItem(attr);
			
			return attr ? attr.value : null;
		}
		
		static SetAttribute(domNode, attr, value) {
			domNode.setAttribute(attr, value);
		}
		
		static Geometry(node) {
			var style = window.getComputedStyle(node);
			
			var h = +(style.getPropertyValue("height").slice(0, -2));
			var w = +(style.getPropertyValue("width").slice(0, -2));
			var pL = +(style.getPropertyValue("padding-left").slice(0, -2));
			var pR = +(style.getPropertyValue("padding-right").slice(0, -2));
			var pT = +(style.getPropertyValue("padding-top").slice(0, -2));
			var pB = +(style.getPropertyValue("padding-bottom").slice(0, -2));
			
			var w = w - pL - pR;
			var h = h - pT - pB;
			
			// Use smallest width as width and height for square grid that fits in container
			// var s = w < h ? w : h;
			
			return { w : w , h : h }
		}
	}

	class Evented { 

		constructor() {
			this.listeners = {};
		}

		addEventListener(type, callback, once){
			if (!(type in this.listeners)) this.listeners[type] = [];
			
			var h = { target:this, type:type, callback:callback, once:!!once };
			
			this.listeners[type].push(h);
			
			return h;
		}
		
		removeEventListener(type, callback){
			if (!(type in this.listeners)) return;
		  
			var stack = this.listeners[type];
			  
			for (var i = 0, l = stack.length; i < l; i++){
				if (stack[i].callback === callback){
					stack.splice(i, 1);
					
					return this.removeEventListener(type, callback);
				}
			}
		}
		
		dispatchEvent(event){
			if (!(event.type in this.listeners)) return;

			var stack = this.listeners[event.type];

			event.target = this;

			for (var i = 0; i < stack.length; i++) {
				stack[i].callback.call(this, event);
			}
			
			for (var i = stack.length - 1; i >= 0; i--) {
				if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
			}
		}
		
		Emit(type, data) {
			var event = { type:type, bubbles:true, cancelable:true };
		
			Util.Mixin(event, data);
			
			this.dispatchEvent(event);
		}
		
		On(type, callback) {
			return this.addEventListener(type, callback, false);
		}

		Once(type, callback) {
			return this.addEventListener(type, callback, true);
		}

		Off(type, callback) {
			this.removeEventListener(type, callback);
		}
	}

	class Templated extends Evented { 

		constructor(container, options) {
			super();
			
			this.options = options || { };
			
			this.BuildTemplate();
			
			if (this.template) this.SetNamedNodes();
		
			if (this.template) this.BuildSubWidgets();
			
			if (container) this.Place(container);
		}
		
		BuildTemplate() {
			// Use template provided in options first, use Template function second
			var html = this.options.template ? this.options.template : this.Template();
			
			// TODO : I think it still works with empty templates.
			if (!html) return;
			
			// Trailing whitespaces can cause issues when parsing the template, remove them
			html = html.trim();
			
			// Replace all nls strings in template. Nls string pattern in templates is nls(StringId)
			html = this.Replace(html, /nls\((.*?)\)/, function(m) { return Core.Nls(m); });
			
			this.template = Dom.Create("div", { innerHTML:html });
		}
		
		SetNamedNodes() {		
			var named = this.template.querySelectorAll("[handle]");
			
			this.nodes = {};
			
			// Can't use Array ForEach here since named is a NodeList, not an array
			for (var i = 0; i < named.length; i++) { 
				var name = Dom.GetAttribute(named[i], "handle");
				
				this.nodes[name] = named[i];
			}
		}
		
		BuildSubWidgets() {
			var nodes = this.template.querySelectorAll("[widget]");
			
			// Can't use Array ForEach here since nodes is a NodeList, not an array
			for (var i = 0; i < nodes.length; i++) {
				var path = Dom.GetAttribute(nodes[i], "widget");
				var module = Core.Templatable(path);
				var widget = new module(nodes[i]);
				var handle = Dom.GetAttribute(widget.container, "handle");
				
				if (handle) this.nodes[handle] = widget;
			}
		}
		
		Place(container) {
			this.container = container;
			
			if (!this.template) return;
			
			while (this.template.children.length > 0) {
				Dom.Place(this.template.children[0], this.container);
			}
		}
		
		Template() {
			return null;		
		}

		Replace(str, expr, delegate) {
			var m = str.match(expr);
			
			while (m) {
				str = str.replace(m[0], delegate(m[1]));
				m = str.match(expr);
			}
			
			return str;
		}
		
		Node(id) {
			return this.nodes[id];
		}
	}

	class Control extends Templated { 
		
		constructor(options) {	
			super(null, options);
			
			if (!this.template) throw new Error("MapBox controls cannot be empty");
			
			if (this.template.children.length > 1) throw new Error("MapBox controls should have one root node");
			
			this._container = this.template.children[0];
		}
		
		onAdd(map) {
	        this._map = map;
			
	        return this._container;
	    }

	    onRemove() {
	        this._container.parentNode.removeChild(this._container);
	        
			this._map = undefined;
	    }
	}

	class Legend extends Control { 
		
		// TODO : All this needs to be made generic
		
		constructor(options) {	
			super(null, options);
			
			this._container = this.Node('root');
			
			this.radios = {
				'cd' : this.Node('rdCD'),
				'ccs' : this.Node('rdCCS'),
				'csd' : this.Node('rdCSD'),
				'da' : this.Node('rdDA'),
			};
			
			this.current = 'cd';
			
			this.radios[this.current].checked = true;
			
			this.radios.cd.addEventListener('change', this.onChange_Handler.bind(this, 'cd'));
			this.radios.ccs.addEventListener('change', this.onChange_Handler.bind(this, 'ccs'));
			this.radios.csd.addEventListener('change', this.onChange_Handler.bind(this, 'csd'));
			this.radios.da.addEventListener('change', this.onChange_Handler.bind(this, 'da'));
		}
		
		onChange_Handler(layer, ev) {
			this.radios[this.current].checked = false;
			
			this._map.setLayoutProperty(this.current, 'visibility', 'none');

			this.current = layer;
			
			this._map.setLayoutProperty(this.current, 'visibility', 'visible');
		}
		
		Template() {
			return "<div handle='root' class='legend mapboxgl-ctrl mapboxgl-ctrl-group'>" +
					  "<div class='legend-label'>nls(Toc_Legend)</div>" +
					  "<div class='legend-container'>" +
						"<div class='legend-item legend-item-1'>" + 
							"<div class='legend-icon'></div>" +
							"<div>nls(Legend_Item_1)</div>" +
						"</div>" +
						
						"<div class='legend-item legend-item-2'>" + 
							"<div class='legend-icon'></div>" +
							"<div>nls(Legend_Item_2)</div>" +
						"</div>" +
					  "</div>" +
					  
					  "<div class='legend-label'>nls(Toc_Instruction)</div>" +
					  "<div class='legend-container toc-container'>" +
						"<label><input handle='rdCD' type='radio' name='boundary' value='male'>CD</label>" +
						"<label><input handle='rdCCS' type='radio' name='boundary' value='female'>CCS</label>" +
						"<label><input handle='rdCSD' type='radio' name='boundary' value='other'>CSD</label>" +
						"<label><input handle='rdDA' type='radio' name='boundary' value='other'>DA</label>" +
					  "</div>" +
				  "</div>";
		}
	}

	class Factory {

		static Map(container, style, center, zoom) {
			return new mapboxgl.Map({ container: container, style: style, center: center, zoom: zoom });
		}
		
		static NavigationControl() {
			return new mapboxgl.NavigationControl();
		}
		
		static GeolocateControl() {
			return new mapboxgl.GeolocateControl({
				positionOptions: { enableHighAccuracy: true },
				trackUserLocation: true
			});
		}
		
		static ScaleControl(units) {
			return new mapboxgl.ScaleControl({
				maxWidth: 80,
				unit: units
			});
		}
		
		static AttributionControl() {
			return new mapboxgl.AttributionControl({ compact: true });
		}
		
		static LegendControl() {
			return new Legend({ });
		}
	}

	class Utils {
		
		static HTMLize(json) {
			var html = "";

			for (var key in json) {
				if (key == "tilequery") continue;
				
				html += `<div class='row'><span>${key} : </span><span>"${json[key]}"</span></div>`;
			}
			
			return `<div class='popup-inner'>${html}</div>`;
		}
	}

	class Map {

		static set Token(value) { mapboxgl.accessToken = value; }
		
		static get Token() { return mapboxgl.accessToken; }
		
		static InfoPopup(map, lngLat, html) {	
			var popup = new mapboxgl.Popup({ closeOnClick: true })
									.setLngLat(lngLat)
									.setHTML(html)
									.addTo(map);
		}
		
		static Choropleth(map, layers, classes) {
			layers.forEach(function(l) {
				map.setPaintProperty(l, 'fill-color', classes);
			});
		}
		
		static ReorderLayers(map, layers) {
			layers.forEach(function(l) { map.moveLayer(l); });
		}
	}

	/*
		tileset = 'staubibr.2ipbn29t';

		map.on('click', function(ev) {
			var lat = ev.lngLat.lat;
			var lng = ev.lngLat.lng;
			var url = "https://api.mapbox.com/v4/" + tileset + "/tilequery/" + lng + "," + lat + ".json?radius=10&access_token=" + mapboxgl.accessToken + "&layers=" + layers.join(",").replace(/-/g, "_");
			
			Request(url, function(ev) {
				var coll = JSON.parse(ev);
				
				if (coll.features.length == 0) return;
				
				var json = coll.features[0].properties;
				
				var popup = new mapboxgl.Popup({closeOnClick: true})
					.setLngLat([lng, lat])
					.setHTML(HTMLize(json))
					.addTo(map);
			}, function(ev) {
				alert(JSON.stringify(ev));
			});
		});
	*/

	class Net {
		
		static Request(url, success, failure) {
			var xhttp = new XMLHttpRequest();
			
			xhttp.onreadystatechange = function() {
				if (this.readyState != 4) return;
			
				// TODO : Switched to this.response, check if it breaks anything
				if (this.status == 200) success(this.response);
				
				else failure({ status:this.status, response:this.response });
			};
			
			xhttp.open("GET", url, true);
			
			xhttp.send();
		}
		
		static GetUrlParameter (name) {				
			name = name.replace(/[\[\]]/g, '\\$&');
			
			var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
			
			results = regex.exec(window.location.href);
			
			if (!results) return null;
			
			if (!results[2]) return '';
			
			return decodeURIComponent(results[2].replace(/\+/g, ' '));
		}
		
		static Download(name, content) {
			var link = document.createElement("a");
			
			link.href = "data:application/octet-stream," + encodeURIComponent(content);
			link.download = name;
			link.click();
			link = null;
		}
	}

	class Popup extends Templated { 
		
		set Widget(value) {
			this.widget = value;
			
			this.widget.Place(this.Node("body"));
		}
		
		get Widget() { return this.widget; }
		
		constructor() {	
			super(document.body);
			
			this.widget = null;
			
			this.Node("close").addEventListener("click", this.onBtnClose_Click.bind(this));
			
			this.Hide();
		}
			
		Show() {
			this.Node("root").style.opacity = 1;
			this.Node("root").style.visibility = "visible";
		}
		
		Hide() {
			this.Node("root").style.opacity = 0;
			this.Node("root").style.visibility = "hidden";
		}
		
		onBtnClose_Click(ev) {
			this.Hide();
		}
		
		Template() {
			return "<div handle='root' class='popup'>" +
					  "<div class='popup-container'>" +
						  "<div class='popup-header'>" +
							  "<div class='popup-title' handle='title'></div>" +
							  "<button class='close' handle='close'>×</button>" +
						  "</div>" +
						
						  "<div class='popup-body' handle='body'></div>" +
					  "</div>" +
				  "</div>";
		}
	}

	var Tooltip = Core.Templatable("UI.Tooltip", class Tooltip {
		
		constructor(container) {				

		}
		
		Template() {
			return '<div handle="root" class="tooltip">' +
					  '<div handle="content"></div>' +
				   '</div>';
		}
		
		PositionTarget(target, offset) {
			offset = offset || [0,0];
			
			bbox1 = target.getBoundingClientRect();
			bbox2 = this.Node("root").getBoundingClientRect();
			
			var x = bbox1.left +  bbox1.width / 2 - bbox2.width / 2 + offset[0];
			var y = bbox1.top + document.documentElement.scrollTop - bbox2.height - 5  + offset[1];
			
			this.PositionXY(x, y);
		}
		
		PositionXY(x, y) {
			this.Node("root").style.left = x + "px";
			this.Node("root").style.top = y + "px";
					
			if (this.BBox.left + this.BBox.width > window.innerWidth) {
				this.Node("root").style.top = y + 30 + "px";
				this.Node("root").style.left = -180 + x + "px";
			}
		}
		
		Show(x, y) {
			this.PositionXY(x, y);
			
			this.Node("root").style.opacity = 1;
		}
		
		Hide() {
			this.Node("root").style.opacity = 0;
		}
		
		Empty() {
			Dom.Empty(this.Node("content"));
		}
		
		get BBox() {
			return this.Node("root").getBoundingClientRect();
		}
	});

	// Static tools

	class BT {
		
	    static get nls() { return Core.nls; }
		
	    static set nls(value) { Core.nls = value; }
		
	    static get locale() { return Core.locale; }
		
	    static set locale(value) { Core.locale = value; }
		
		static get Core() { return Core; }
		
		static get Net() { return Net; }
		
		static get Dom() { return Dom; }
		
		static get Util() { return Util; }
		
		static get Components() {
			return {
				Evented : Evented,
				Templated : Templated,
				Popup : Popup,
				Tooltip : Tooltip
			};
		}
	}

	// Static tools

	class MBT {
		
	    static get Nls() { return BT.Core.nls; }
		
	    static set Nls(value) { BT.Core.nls = value; }
		
	    static get Locale() { return BT.Core.locale; }
		
	    static set Locale(value) { BT.Core.locale = value; }
		
		static set Token(value) { Map.Token = value; }
		
		static get Token() { return Map.Token; }
		
		static get Factory() { return Factory; }
		
		static get Utils() { return Utils; }
		
		static get Map() { return Map; }
		
		static get BT() { return BT; }
	}

	// This is a workaround for ie11 because it doesn't support es6. The point is to wrap the 

	window.MBT = MBT;

}());
